% Chapter 6

\chapter{Automated Reconfiguration}
\label{Chapter 6}
\lhead{}

% 1 . Overview - what is the purpose of an agent?
\section{Overview}
This chapter discusses automated network reconfiguration and how it is supported by the work of this thesis. First, the concept of automated reconfiguration and the motivation for its use is described. Then the design and implementation of the automated reconfiguration software in the work of this thesis is described. Finally, an example is shown that demonstrates the practical uses of this software.

% 2. Design 
%	- describe automated user & message processor 
%	- message processor is what distinguishes one agent from another 
%		- message processor can be made with a lambda and passed around as a first-class object (treating a function as a variable)
%		- cite this concept of lambda as a first class object
%	- the need to validate and separate permission checking from the automated user
%		- provides the motivation for a agentController
%	- mention how automated user is using the same logic/code from earlier in the paper
%		- using the same command classes
%		- automation is a natural extension of the work in the previous chapters
%	- class diagram of how all the classes fit together

\section{Requirements}
The work in this thesis allows network reconfiguration through user interaction. User interaction can sometimes be inadequate because of slow response time, a lack of understanding of system behavior, or human error. Creating a system that can automatically respond to incoming sensor data (or calculations derived from incoming sensor data) by reconfiguring the network overcomes many limitations encountered by requiring user input.


% 1. Describe the automated user class and how it needs to support several things when new automated users are implemented:
% - be able to handle received messages and exceptions that may be encountered
% - be able to adhere to the user access and safety validations of the rest of the system
% NOT allow some automated users to overwrite the UAC and safety validation
% NOT directly interact with the database
The software applications designed in this work to autonomously monitor and reconfigure WiSARDs are called automated agents. Agents must fulfill three main requirements. First, the agents must adhere to the user access and safety validations that govern the rest of the system. More specifically, the developers of automated agents should not be allowed to intentionally or unintentionally bypass, improperly implement, or override the security provisions. Second, they must be able to receive and handle WiSARD data streams as well as any exceptions that may occur. WiSARD data streams are accessible to applications by using an MQTT subscription client. These data streams are called messages. Finally, the agents should be able to interact with the other CI systems. For instance, an agent should be able to interact with the PostgreSQL database using the query methods that the WiSARD class provides.

\section{Design}
The automated agents are defined by a Java class designed to address these requirements. The first requirement of preventing agents from circumventing system security is solved by separating the validation logic from the Agent Class. If the validation logic is external to the Agent Class, then agents will not be able to dictate their own security privileges. The second requirement of receiving and handling data streams and handling exceptions specific to each agent is solved by the design decision that each agent has message handling logic and exception handling logic that can be specific to that agent. The final requirement of allowing an agent to interact with the other parts of the CI  is solved by using the functionality in Wisard\_Browser\_Module, Cmd\_Generation\_Module, and Validation\_Module. For instance, an agent can use the WiSARD Class discussed in Chapter 5 as a means of interacting with the database.

To implement this design, the AgentController Class is used and encapsulates much of the functionality described in the previous chapters, primarily validation and safety. The controller class will log in an agent, validate that it has sufficient privileges to access the data streams it uses, and then create an agent object. The agent class implements the Java runnable interface, allowing the agent to be put into a thread and executed. The design and implementation of the agents is generalized, so that there is common code from agent to agent. Every agent uses the same logic to listen for and handle incoming messages. Message processing and error logic that distinguishes one agent from another are passed to the agent as parameters in the form of lambda expressions (anonymous functions).

Using inheritance in object-oriented software design is typically a good way to reuse code. Inheritance has been used extensively in the code described in the previous chapters. However, in the case of designing the automation behavior, using aggregation over inheritance resulted in a cleaner design. Aggregation is the object-oriented design concept where the functionality of an object is determined by the aggregation of other objects, as opposed to implementing or inheriting the functionality directly. This approach is accomplished with the use of two interfaces referred to as the MessageProcessor and the ErrorHandler. These interfaces allow the operational logic for each agent to be passed in as lambda expressions to an Agent object during its creation. Figure \ref{fig:automation_class_diagram} is a UML class diagram that shows how agents are implemented using aggregation.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{figures/automated_agent_class_diagram.png}
	\caption{A UML class diagram showing the classes and interfaces necessary to instantiate AutomatedAgent objects. The arrows describe the relationships between the four different classes as well as the two interfaces. }
	\label{fig:automation_class_diagram}
\end{figure}

AutomatedAgentController, AutomatedAgent, Person, and Message are each a class. MessageProcessor and ErrorHandler are functional interfaces. A functional interface defines a type for a lambda expression. This is necessary so that variables can be created to reference lambda expressions.  The text on each of the arrows describes the relationship between the classes and interfaces used in the automation software. The AutomatedAgentController class \verb|<<uses>>| the MessageProcessor and ErrorHandler interfaces to store lambda expressions that implement the logic for processing messages and for handling errors, respectively.

The AutomatedAgentController class \verb|<<create>>| instances of both the Person class and the AutomatedAgent class. An AutomatedAgentController takes in the two lambda expressions, creates a Person object, and passes those along into the constructor of AutomatedAgent class to create new agents. 

Each AutomatedAgent object can then use its Person object, the functionality in the Message class, and whatever lambda expressions that were passed in as the MessageProcessor and ErrorHandler. A detailed example of the software classes showing how this software works is described in the next section.

\section{Example Agent}
% 3. Example description and code for a very simple agent
%	- flow of execution visual?%
Using the design described in the previous section, there are many different ways that an automated agent can be used to manage WiSARDs. The following code snippets demonstrate how this software is used in practice by showing the class definitions for AutomatedAgentController and AutomatedAgent, the definitions for the MessageProcessor and ErrorHandler functional interfaces, as well as an example program which demonstrates how to use these classes.

Below is a simplified class definition for the AutomatedAgentController class that handles authentication, creation, and execution of the agents.
% AutomatedUserController class
\lstinputlisting[language = java, firstline = 32, lastline=44]{AutomatedUser.java}
 
The code snippet shown below contains the definitions for the functional interfaces that allow lambda expressions to be passed to the agents that define their behavior. A type is a notation that specifies how variables or objects should be interpreted and used. As described in the previous section, functional interfaces specify a type that allows lambda expressions to be saved to variables and used by the agents. In the case of these interfaces, the types are MessageProcessor and ErrorHandler. 

 % Interfaces
 \lstinputlisting[language = java, firstline = 16, lastline=30]{AutomatedUser.java}
 
The snippet shown below is the class definition for AutomatedAgent. In the constructor, all necessary information to establish connections to MQTT message brokers as well as define the agent's behavior is passed in as a set of parameters. The method \verb|run()| establishes its subscriptions with the MQTT brokers it will be listening to, and then waits for messages to arrive. Once messages arrive, they are given to \verb|processMessage()| whose functionality was passed into the constructor as a lambda expression. Additionally, any exceptions are passed to \verb|handleError()| whose functionality was also passed to the constructor as a lambda expression.

%\lstinputlisting[language = java, firstline = 46, lastline=62]{AutomatedUser.java}
  
 % AutomatedUser class	
 \lstinputlisting[language = java, firstline = 64, lastline=132]{AutomatedUser.java}
 
 The final code snippet below shows a simple example of how to utilize the classes defined above in an agent that automatically reconfigures a WiSARD. This example program creates an agent that toggles between two different sampling rates every 12 hours. The \verb|main()| method shown at the bottom of this example uses the AutomatedAgentController class to instantiate an AutomatedAgent object with the \verb|createAutomatedAgent()| method. Note that no instance of the AutomatedAgentController class created. This is because the method is declared to be static. Likewise, \verb|runCommand()| is also static. The Java Virtual Machine (JVM) allows static methods to be called without creating an instance of the class that defined them.
 
 \lstinputlisting[language = java, firstline = 7, lastline = 79]{Agent_example.java}
 
 

 	
%There are many different ways in which an automated agent can be used to manage WiSARDs in the WiSARDNet platform. For a practical example, assume a researcher desires to capture a set of high resolution soil moisture readings of rain events in a particular area, but does not want their WiSARD to sample at a high rate when there are no rain events. An automated agent could be used to identify pending storms from neighboring areas by monitoring their soil moisture data readings, and then preemptively updating the sampling rate of the WiSARDs at the region of interest.\\

%To create an automated agent with this functionality the steps described in the previous section need to be taken.

%\begin{itemize}
%	\item Define a Message Processor with the logic it will use to monitor the data streams of interest.
%	\item Create an ArrayList data structure of subscription objects with the connection information to the different sites it will be monitoring.
%	\item Create an Automated Agent Controller object
%	\item Use the Automated Agent Controller to create and authenticate an Automated Agent
%	\item Run the Automated agent.
%\end{itemize}

%\textbf{Show the code that defines a message processor}

%\textbf{Show the code that creates the arraylist of subscription objects as well as the class definition for subscription objects}

%\textbf{Show the code that creates the Automated Agent Controller and the Automated Agent as well as class definitions for both}

%\text{Show the code that runs the Agent and the logic it executes}